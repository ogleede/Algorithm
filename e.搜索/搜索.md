搜索的方法有多种，可以涉及数组、树、图等等数据结构，以及深度优先遍历、广度优先遍历、回溯、拓扑排序等等方法。



[**Leetcode 695 最大的岛屿面积- Medium**](https://leetcode-cn.com/problems/max-area-of-island/)

```java
class Solution {
    private int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};
    private boolean[][] seen;
    private int r, c, res;
    
    private boolean inArea(int x, int y) {
        return x >= 0 && x < r && y >= 0 && y < c;
    }
    
    private int dfs(int[][] grid, int x, int y) {
        seen[x][y] = true;
        int tmp = 1;
        for(int[] dir : dirs) {
            int nx = x + dir[0], ny = y + dir[1];
            if(!inArea(nx, ny) || seen[nx][ny] || grid[nx][ny] == 0) continue;
            tmp += dfs(grid, nx, ny);
        }
        return tmp;
    }
    
    public int maxAreaOfIsland(int[][] grid) {
        r = grid.length;
        c = grid[0].length;
        res = 0;
        seen = new boolean[r][c];
        for(int i = 0; i < r; ++i) {
            for(int j = 0; j < c; ++j) {
                if(grid[i][j] == 1) {
                    res = Math.max(res, dfs(grid, i, j));
                }
            }
        }
        return res;
    }
}
```

> 这题在遍历时不需要对seen数组进行回溯，找到后就标记以剪枝。

```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int res = 0;
        int m = grid.length;
        int n = grid[0].length;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                Deque<Integer> queuei = new LinkedList<>();
                Deque<Integer> queuej = new LinkedList<>();
                queuei.offer(i);
                queuej.offer(j);
                int cur = 0;
                while(queuei.size() > 0){
                    int cur_i = queuei.poll();
                    int cur_j = queuej.poll();
                    if(cur_i < 0 || cur_i >= m || cur_j < 0 || cur_j >= n || (grid[cur_i][cur_j] == 0)){
                        continue;
                    }
                    grid[cur_i][cur_j] = 0;
                    ++cur;
                    queuei.push(cur_i);
                    queuei.push(cur_i);
                    queuei.push(cur_i + 1);
                    queuei.push(cur_i - 1);
                    queuej.push(cur_j + 1);
                    queuej.push(cur_j - 1);
                    queuej.push(cur_j);
                    queuej.push(cur_j);
                }
                res = Math.max(res, cur);
            }
        }
        return res;
    }
}
```

> 这种多源BFS的写法。。。太丑了，每个源都重新new队列，不过逻辑简单。











**[剑指Offer32 - I 从上到下打印二叉树 I - Medium](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)**

```java
class Solution {
    public int[] levelOrder(TreeNode root) {
        if(root == null) return new int[0];
        List<Integer> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()) {
            int size = queue.size();
            for(int i = 0; i < size; ++i) {
                TreeNode node = queue.poll();
                res.add(node.val);
                if(node.left  != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            }
        }
        int[] a = new int[res.size()];
        for(int i = 0; i < res.size(); ++i) {
            a[i] = res.get(i);
        }
        return a;
    }
}
```

* 留个坑 ： List.toArray()方法



**[剑指Offer32 - II 从上到下打印二叉树 II - Easy](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)**

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root == null) return new ArrayList<>();
        List<List<Integer>> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()) {
            List<Integer> tmp = new ArrayList<>();
            int size = queue.size();
            for(int i = 0; i < size; ++i) {
                TreeNode node = queue.poll();
                tmp.add(node.val);
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            }
            res.add(tmp);
        }
        return res;
    }
}
```



**[剑指Offer32 - III 从上到下打印二叉树 III - Medium](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)**

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root == null) return new ArrayList<>();
        List<List<Integer>> res = new ArrayList<>();
        Deque<TreeNode> deque = new ArrayDeque<>();
        deque.addLast(root);
        int even = 0;
        while(!deque.isEmpty()) {
            List<Integer> tmp = new ArrayList<>();
            int size = deque.size();
            for(int i = 0; i < size; ++i) {
                if((even & 1) == 0) {
                    TreeNode node = deque.pollLast();
                    tmp.add(node.val);
                    if(node.left != null) deque.addFirst(node.left);
                    if(node.right != null) deque.addFirst(node.right);
                }else {
                    TreeNode node = deque.pollFirst();
                    tmp.add(node.val);
                    if(node.right != null) deque.addLast(node.right);   
                    if(node.left != null) deque.addLast(node.left);
                }              
            }
            even ^= 1;
            res.add(tmp);
        }
        return res;
    }
}
```

> 因为不想假的Z形遍历（即还是按照层序遍历，但是最后打印是反向输出）。
>
> 利用even变量标志该行的遍历逻辑
>
> 利用双端队列，add和poll的方向相反。
>
> 为了保证顺序正确，当even为奇数时，需要先访问right节点，再访问left节点。画个图就明白了。



**[剑指Offer 26 树的子结构 - Medium](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)**

```java
class Solution {
    private boolean recur(TreeNode A, TreeNode B) {
        if(B == null) return true;
        if(A == null || A.val != B.val) return false;
        return recur(A.left, B.left) && recur(A.right, B.right);
    }
    
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        return (A != null && B != null) && (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));
    }
}
```

> 这题一直没理解透。主递归是当A和B当前节点就可以匹配，或者A的子节点再和B匹配
>
> recur是进行一对一匹配、



**[剑指Offer 27 二叉树的镜像 - Easy](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)**

```java
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if(root == null) return root;
        TreeNode tmp = root.left;
        root.left = mirrorTree(root.right);
        root.right = mirrorTree(tmp);
        return root;
    }
}

class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if(root == null) return root;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if(node.left != null) queue.add(node.left);
            if(node.right != null) queue.add(node.right);
            TreeNode tmp = node.left;
            node.left = node.right;
            node.right = tmp;
        }
        return root;
    }
}
```

> 层序遍历时，正常入队，每个节点都交换左右节点，即实现了镜像翻转。



**[剑指Offer 28 二叉树的镜像 - Easy](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)**

```java
class Solution {
    private boolean recur(TreeNode l, TreeNode r) {
        if(l == null && r == null) return true;
        if(l == null || r == null || l.val != r.val) return false;
        return recur(l.left, r.right) && recur(l.right, r.left);
    }
    
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;
        return recur(root.left, root.right);
    }
}
```



**[剑指Offer 12 矩阵中的路径 - Medium](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)**

```java
class Solution {
    private int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};
    private boolean[][] seen;
    private int r, c;
    
    private boolean inArea(int x, int y) {
        return x >=0 && x < r && y >= 0 && y < c;    
    }
    
    private boolean dfs(char[][] board, int x, int y, int idx, String word) {
        if(idx == word.length() - 1 && board[x][y] == word.charAt(idx)) return true;//******
        if(board[x][y] != word.charAt(idx)) return false;
        seen[x][y] = true;
        boolean res = false;
        for(int[] dir : dirs) {
          	if(res) break;
            int nx = x + dir[0], ny = y + dir[1];
            if(inArea(nx, ny) && !seen[nx][ny]) res |= dfs(board, nx, ny, idx + 1, word);
        }
        seen[x][y] = false;
        return res;
    }
    
    public boolean exist(char[][] board, String word) {
        r = board.length;
        c = board[0].length;
        seen = new boolean[r][c];
        for(int i = 0; i < r; ++i) {
            for(int j = 0; j < c; ++j) {
                if(dfs(board, i, j, 0, word)) return true;
            }
        }
        return false;
    }
}
```

> （*）处要提前退出，不然如果四周都越界，无法返回正确值。
>
> 循环时写四个新方向，可能会忽略短路特性。加上break条件，可以实现短路。



**[剑指Offer 13 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/submissions/)**

```java
class Solution {
    private boolean[][] seen;
    private int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};
    private int r, c, k, res;
    
    private boolean inArea(int x, int y) {
        return x >= 0 && x < r && y >= 0 && y < c;
    }
    
    private int getSum(int x, int y) {
        int sum = 0;
        while(x != 0) {
            sum += x % 10;
            x /= 10;
        }
        while(y != 0) {
            sum += y % 10;
            y /= 10;
        }
        return sum;
    }
    
    private void dfs(int x, int y) {
        if(seen[x][y] || getSum(x, y) > k) return;
        seen[x][y] = true;
        ++res;
        for(int[] dir : dirs) {
            int nx = x + dir[0], ny = y + dir[1];
            if(inArea(nx, ny) && !seen[nx][ny]) dfs(nx, ny);
        }
    }
    
    public int movingCount(int m, int n, int k) {
        r = m;
        c = n;
        this.k = k;
        res = 0;
        seen = new boolean[r][c];
        dfs(0, 0);
        return res;
    }
}


class Solution {
    private boolean[][] seen;
    private int[][] dirs = {{1,0},{0,1}};
    private int r, c, k, res;
    
    private boolean inArea(int x, int y) {
        return x >= 0 && x < r && y >= 0 && y < c;
    }
    
    private int getSum(int x, int y) {
        int sum = 0;
        while(x != 0) {
            sum += x % 10;
            x /= 10;
        }
        while(y != 0) {
            sum += y % 10;
            y /= 10;
        }
        return sum;
    }
    
    private void dfs(int x, int y) {
        if(seen[x][y] || getSum(x, y) > k) return;
        seen[x][y] = true;
        ++res;
        for(int[] dir : dirs) {
            int nx = x + dir[0], ny = y + dir[1];
            if(inArea(nx, ny) && !seen[nx][ny]) dfs(nx, ny);
        }
    }
    
    public int movingCount(int m, int n, int k) {
        r = m;
        c = n;
        this.k = k;
        res = 0;
        seen = new boolean[r][c];
        dfs(0, 0);
        return res;
    }
}

class Solution {
    private int r, c;
    
    private boolean inArea(int x, int y) {
        return x >= 0 && x < r && y >= 0 && y < c;
    }
    
    private int getSum(int x, int y) {
        int sum = 0;
        while(x != 0) {
            sum += x % 10;
            x /= 10;
        }
        while(y != 0) {
            sum += y % 10;
            y /= 10;
        }
        return sum;
    }

    public int movingCount(int m, int n, int k) {
        r = m;
        c = n;
        boolean[][] seen = new boolean[r][c];
        int[][] dirs = {{1,0},{0,1}};
        Queue<Integer> queuei = new LinkedList<>();
        Queue<Integer> queuej = new LinkedList<>();
        queuei.add(0);
        queuej.add(0);
        int res = 1;
        seen[0][0] = true;
        while(!queuei.isEmpty()) {
            int x = queuei.poll(), y = queuej.poll();
            for(int[] dir : dirs) {
                int nx = x + dir[0], ny = y + dir[1];
                if(!inArea(nx, ny) || seen[nx][ny] || getSum(nx, ny) > k) continue;
                seen[nx][ny] = true;
                ++res;
                queuei.offer(nx);
                queuej.offer(ny);
            }
        }
        return res;
    }
}
```

> 起点是[0, 0],只需要向下，向右就可以到达所有可达点。
>
> BFS方法中，在添加节点时，计数+添加seen可以实现功能。
>
> 我尝试过另一种代码，即在poll节点时，计数+添加seen

```java
class Solution {
    private int r, c;
    
    private boolean inArea(int x, int y) {
        return x >= 0 && x < r && y >= 0 && y < c;
    }
    
    private int getSum(int x, int y) {
        int sum = 0;
        while(x != 0) {
            sum += x % 10;
            x /= 10;
        }
        while(y != 0) {
            sum += y % 10;
            y /= 10;
        }
        return sum;
    }

    public int movingCount(int m, int n, int k) {
        r = m;
        c = n;
        boolean[][] seen = new boolean[r][c];
        int[][] dirs = {{1,0},{0,1}};
        Queue<Integer> queuei = new LinkedList<>();
        Queue<Integer> queuej = new LinkedList<>();
        queuei.add(0);
        queuej.add(0);
        int res = 0;
        while(!queuei.isEmpty()) {
            int x = queuei.poll(), y = queuej.poll();
            ++res;
            seen[x][y] = true;
            for(int[] dir : dirs) {
                int nx = x + dir[0], ny = y + dir[1];
                if(!inArea(nx, ny) || seen[nx][ny] || getSum(nx, ny) > k) continue;
                queuei.offer(nx);
                queuej.offer(ny);
            }
        }
        return res;
    }
}
```

> poll时更改，会将节点重复入队。



**[剑指Offer 34 二叉树中和为某一值的路径 - Medium](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)**

```java
class Solution {
    private List<List<Integer>> res;
    private List<Integer> path;
    private int t;
    
    private void dfs(TreeNode root, int val) {
        if(root == null) return;
        path.add(root.val);
        val += root.val;
        if(val == t && root.left == null && root.right == null) {
            res.add(new ArrayList<>(path));
        }
        dfs(root.left, val);
        dfs(root.right, val);
        path.remove(path.size() - 1);
    }
    
    public List<List<Integer>> pathSum(TreeNode root, int t) {
        res = new ArrayList<>();
        if(root == null) return res;
        path = new ArrayList<>();
        this.t = t;
        dfs(root, 0);
        return res;
    }
}
```

> 挺简单一道题，写错了好多遍。。题目要求是从根节点到叶子节点，

```java
class Solution {
    private List<List<Integer>> res;
    private List<Integer> path;
    private int t;
    
    private void dfs(TreeNode root, int val) {
        if(root == null) return;
        path.add(root.val);
        val += root.val;
        if(val == t && root.left == null && root.right == null) {
            res.add(new ArrayList<>(path));
            return;//******
        }
        dfs(root.left, val);
        dfs(root.right, val);
        path.remove(path.size() - 1);
    }
    
    public List<List<Integer>> pathSum(TreeNode root, int t) {
        res = new ArrayList<>();
        if(root == null) return res;
        path = new ArrayList<>();
        this.t = t;
        dfs(root, 0);
        return res;
    }
}
```

> 星号的地方，如果提前返回，那么当前全局的path和回溯节点需要删除掉的节点就失去同步了。



**[剑指Offer 36 BST转换为双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)**

```java
class Solution {
    private Node head, pre;
    
    private void dfs(Node cur) {
        if(cur == null) return;
        dfs(cur.left);
        if(pre != null) {
            pre.right = cur;
        }else {
            head = cur;
        }
        cur.left = pre;
        pre = cur;
        dfs(cur.right);
    }
    
    public Node treeToDoublyList(Node root) {
        if(root == null) return root;
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    }
}
```

> 维护全局变量的前后指针。



**[剑指Offer 54 BST第k大节点值](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)**

```java
class Solution {
    private int res, k;
    
    private void dfs(TreeNode node) {
        if(node == null) return;
        dfs(node.right);       
        if(k <= 0) return;
        if(--k == 0) {
            res = node.val;
            return;
        }
        dfs(node.left);
    }
    
    public int kthLargest(TreeNode root, int k) {
        res = 0;
        this.k = k;
        dfs(root);
        return res;
    }
}
```

> 要在遍历到当前节点时再对k进行改变。
>
> 如果不采用全局变量，这个k不好控制。



**[剑指Offer55 - I 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)**

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```





**[剑指Offer55 - II 判断平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)**

```java
//从顶向下，有重复计算。
//不过我觉得把求深度放在后面，可以利用短路特性减少重复计算次数
class Solution {
    private int maxDepth(TreeNode root) {
        if(root == null) return 0;
        return Math.max(maxDepth(root.right), maxDepth(root.left)) + 1;
    }
    
    public boolean isBalanced(TreeNode root) {
        if(root == null) return true;
        return isBalanced(root.left) && isBalanced(root.right) && Math.abs(maxDepth(root.left) - maxDepth(root.right)) <= 1;
    }
}

//最优解，从底向上
class Solution {
    private int recur(TreeNode root) {
        if(root == null) return 0;
        int left = recur(root.left);
        if(left == -1) return -1;
        int right = recur(root.right);
        if(right == -1) return -1;
        return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1;
    }
    
    public boolean isBalanced(TreeNode root) {
        return recur(root) != -1;
    }
}
```

> 第一个解法还是没有利用短路特性剪枝成功，由于isBalanced函数没有返回false的额外条件，只能依赖深度函数。



**[剑指Offer 64 1~n求和](https://leetcode-cn.com/problems/qiu-12n-lcof/)**

```java
class Solution {
    public int sumNums(int n) {
        boolean tmp = n > 1 && (n += sumNums(n - 1)) > 0;
        return n;
    }
}
```

> 构造boolean变量



**[剑指Offer 68 - I BST的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)**

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || q == root || p == root || (p.val < root.val && q.val > root.val) || (p.val > root.val && q.val < root.val)) return root;
        if(p.val < root.val) return lowestCommonAncestor(root.left, p, q);
        else return lowestCommonAncestor(root.right, p, q);
    }
}

class Solution {
  	public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
      	if(p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p, q);
      	if(p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right, p, q);
      	return root;
    }
}
```





**[剑指Offer68 - II 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)**

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q) return root;
        TreeNode left  = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if(left == null) return right;
        if(right == null) return left;
        return root;
    }
}
```

> 先序遍历二叉树，当root为LCA时，有3种情况
>
> 1、q，p在root两侧
>
> 2、p,q在root一侧，但p==root
>
> 3、p,q在root一侧，但q==root
>
> 最后的返回root，即是left==null 并且 right == null，说明下面没有更近的祖先，也包含pq在异侧的情况



**[剑指Offer 37 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)**

```java
public class Codec {
  
  	private void dfsEncode(TreeNode root, StringBuilder sb) {
        if(root == null) {
            sb.append("n,");
            return;
        }
        sb.append(root.val);
        sb.append(",");
        dfsEncode(root.left, sb);
        dfsEncode(root.right, sb);
    }
  
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null) return "";
        StringBuilder sb = new StringBuilder();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if(node == null) sb.append("n,");
            else {
                sb.append(node.val).append(",");
                queue.add(node.left);
                queue.add(node.right);
            }
        }
        return sb.toString();
    }
    
    private TreeNode dfs(Queue<String> queue) {
        String poll = queue.poll();
        if("n".equals(poll)) return null;
        TreeNode root = new TreeNode(Integer.parseInt(poll));
        root.left = dfs(queue);
        root.right = dfs(queue);
        return root;
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if("".equals(data)) return null;
        String[] str = data.split(",");
        TreeNode root = new TreeNode(Integer.parseInt(str[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        int i = 1;
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if(!"n".equals(str[i])) {
                node.left = new TreeNode(Integer.parseInt(str[i]));
                queue.add(node.left);
            }
            ++i;
            if(!"n".equals(str[i])) {
                node.right = new TreeNode(Integer.parseInt(str[i]));
                queue.add(node.right);
            }
            ++i;
        }
        return root;
    }
}

```





**[Leetcode 428 序列化N叉树](https://leetcode-cn.com/problems/serialize-and-deserialize-n-ary-tree/)**

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Codec {
    private void dfsEncode(Node root, StringBuilder sb) {
        if(root == null) {
            sb.append("n,");
            return;
        }
        sb.append(root.val).append(",").append(root.children.size()).append(",");
        for(Node child : root.children) dfsEncode(child, sb);
    }
    
    // Encodes a tree to a single string.
    public String serialize(Node root) {
        if(root == null) return "";
        StringBuilder sb = new StringBuilder();
        dfsEncode(root, sb);
        return sb.toString();
    }
	
    private Node dfsDecode(Queue<String> queue) {
        String poll = queue.poll();
        if("n".equals(poll)) return null;
        Node root = new Node(Integer.parseInt(poll), new ArrayList<Node>());
        int size = Integer.parseInt(queue.poll());
        for (int j = 0; j < size; j++) { // 如果size == 0，则跳过，直接返回root
            Node child = dfsDecode(queue);
            root.children.add(child);
        }
        return root;
    }
    
    public Node deserialize(String data) {
        if (data == null || data.isEmpty()) return null;
        Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(",")));
        return dfsDecode(queue);
    }

}
```

> N叉树要带上孩子个数。
>
> 由于和二叉树的构造方法不同，N叉树的子节点为null时，完全可以由list的size代替。



**[剑指Offer 38 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)**

```java
```


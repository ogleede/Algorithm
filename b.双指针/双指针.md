## 2双指针

* 双指针包括搜索和滑动窗口两种类型，搜索时两个指针分别位于区间首尾相向移动，一般要求待搜索序列有序；滑动窗口时两个指针位于相近位置同向移动且不会相交。



**[Leetcode 88 合并两个有序数组 - Easy](https://leetcode-cn.com/problems/merge-sorted-array/)**

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int k = m-- + n-- - 1;
        while(m >= 0 && n >= 0) nums1[k--] = nums1[m] > nums2[n] ? nums1[m--] : nums2[n--];
        while(n >= 0) nums1[k--] = nums2[n--];
    }
}
```

> 从尾向前遍历，妙 ;)



**[Leetcode 142 环形链表II - Medium](https://leetcode-cn.com/problems/linked-list-cycle-ii/)**

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while(true) {
            if(fast == null || fast.next == null) return null;
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow) break;
        }
        slow = head;
        while(fast != slow) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```

> 起点到环入口点，a个点；环入口点到相遇点，b个点；环剩余点，c个点。
>
> fast：a + b + x(b + c)
>
> slow: a + b + y(b + c)
>
> fast = 2slow   ==>   a + b = (x - 2y)(b + c) = n(b + c)   =>  a = c + (n - 1)(b + c) = c + n(b + c);
>
> 可知a 和 c之间差了n圈，所以在相遇时，把一个指针指到头结点，另一个指针不动，他们再相遇时就是环入口点



**[Leetcode 76 最小覆盖字串 - Hard](https://leetcode-cn.com/problems/minimum-window-substring/)**

```java
class Solution {
    public String minWindow(String s, String t) {
        Map<Character, Integer> ht = new HashMap<>();
        for(char c : t.toCharArray()) ht.put(c, ht.getOrDefault(c, 0) + 1);
        char[] cs = s.toCharArray();
        
        int l = 0, r = cs.length - 1;//提前缩短区间
        while(l < cs.length && !ht.containsKey(cs[l])) ++l;
        if(l >= cs.length) return "";
        while(r >= 0 && !ht.containsKey(cs[r])) --r;
        if(r < 0) return "";
        
        Map<Character, Integer> hs = new HashMap<>();
        int len = Integer.MAX_VALUE, cnt = 0;
        String res = "";
        for(int i = l, j = l; j <= r; ++j) {
            hs.put(cs[j], hs.getOrDefault(cs[j], 0) + 1);
            if(ht.containsKey(cs[j]) && hs.get(cs[j]) <= ht.get(cs[j])) ++cnt;
            while(i < j && (!ht.containsKey(cs[i]) || hs.get(cs[i]) > ht.get(cs[i]))) {//够了就放手
                int count = hs.get(cs[i]) - 1;
                hs.put(cs[i], count);
                ++i;
            }
            if(cnt == t.length() && j - i + 1 < len) {
                len = j - i + 1;
                res = s.substring(i, j + 1);
            }
        }
        return res;
    }
}
```

> 滑动窗口yydt，这题用cnt来保证答案包含所有必需值，所需值之一够了才让i左移（放手）



**[Leetcode 633 平方数之和 - Medium](https://leetcode-cn.com/problems/sum-of-square-numbers/)**

```java
class Solution {
    public boolean judgeSquareSum(int c) {
        long lc = (long)c;
        long r = (long)Math.sqrt(lc);
        if(r * r == lc) return true;
        long l = 0;
        while(l <= r) {
            long sum = l * l + r * r;
            if(sum == lc) return true;
            else if(sum < lc) ++l;
            else --r;
        }
        return false;
    }
}
```

> 谨防大数越界



**[Leetcode 340 至少包含K个不同字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/)**

```java
class Solution {
    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        int len = s.length();
        if(len * k == 0) return 0;
        char[] cs = s.toCharArray();
        Map<Character, Integer> map = new LinkedHashMap<>(k + 1);
        int res = 1, cnt = 0;
        for(int i = 0, j = 0; j < cs.length; ++j) {
            if(map.containsKey(cs[j])) map.remove(cs[j]);
            map.put(cs[j], j);
            if(map.size() == k + 1) {
                Map.Entry<Character, Integer> leftmost = map.entrySet().iterator().next();
                map.remove(leftmost.getKey());
                i = leftmost.getValue() + 1;
            }
            res = Math.max(res, j - i + 1);
        }
        return res;
    }
}
```

> 利用LinkedHashMap按顺序记录加入Map中元素。已有该元素，更新该元素位置；超过限额，移除最左边元素，更新左坐标。每轮统计最大长度值。



**[Leetcode 524 通过删除字母匹配到字典里的最长单词](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)**

```java
class Solution {
    public String findLongestWord(String s, List<String> dict) {
        Collections.sort(dict, (a, b) -> {
            if(a.length() != b.length()) return b.length() - a.length();
            else return a.compareTo(b);
        });
        for(String t : dict) {
            int i = 0, j = 0;
            while(i < s.length() && j < t.length()) {
                if(s.charAt(i) == t.charAt(j)) ++j;
                ++i;
            }
            if(j == t.length()) return t;
        }
        return "";
    }
}
```

> 字典序排列，用a.compareTo(b)比较，compareTo是String类自带的方法。

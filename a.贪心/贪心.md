### 1贪心算法的主要思想

​        做过很多的贪心算法题目，我最直观的感受是代码书写简单，数学证明难；往往用动态规划、搜索等方法来实现，代码量极大且难以理解，但掌握了贪心算法后就很“取巧地”解决了。

​       所谓贪心算法：就是以局部最优取得全局最优的方法，前提条件是，**局部结果互不相干**。

#### 1.1 分配问题

**Leetcode 135 分发糖果 - Hard**

题目链接：https://leetcode-cn.com/problems/candy/

```java
class Solution {
    public int candy(int[] ratings) {
        if(ratings == null) return 0;
        int len = ratings.length;
        if(len < 2)         return len;
        
        int[] tmp = new int[len];
        Arrays.fill(tmp, 1);
        //从左向右遍历，当右节点大于左节点，右节点值 = 左节点值 + 1；
        for(int i = 1; i < len; ++i) {
            if(ratings[i] > ratings[i - 1]) {
                tmp[i] = tmp[i - 1] + 1;
            }
        }
        //从右向左遍历，当左节点大于右节点，左节点值 = 右节点值 + 1；
        for(int i = len - 2; i >= 0; --i) {
            if(ratings[i] > ratings[i + 1] && tmp[i] <= tmp[i + 1]) {
                tmp[i] = tmp[i + 1] + 1;
            }
        }
        
        int res = 0;
        for(int num : tmp) res += num;
        return res;
    }
}
```



> 题目隐含条件是，相邻点之间的大小关系是不会改变的，在遍历时，分别从左向右、从右向左遍历两次，保证相邻点之间按照ratings关系，最多差值为1。

> 在遍历时，要依照不变量，改变可变量。比如，从左向右遍历时，当ratings[i + 1] > ratings[i]，我们要改变tmp[i + 1]的值，而不能改变tmp[i]的值，如果改了错误的值，变化关系无法传递下去。

> 两次遍历情况略有不同，第一次遍历可以保证右值一开始小于等于左值的。在第二次遍历时，如果单纯以tmp[i + 1]作为参考更改左值，会毁掉第一次遍历的结果。





#### 1.2 区间问题

**Leetcode 435 无重叠区间 - Medium**

题目链接： https://leetcode-cn.com/problems/non-overlapping-intervals/

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if(intervals == null)   return 0;
        int len = intervals.length;
        if(len < 2)             return 0;
        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);
        int res = 0, pre = intervals[0][1];
        for(int i = 1; i < len; ++i) {
            if(intervals[i][0] < pre) {
                ++res;
            }else {
                pre = intervals[i][1];
            }
        }
        return res;
    }
}
```



> Arrays.sort() 可以对非基本类型的对象排序（因为Comparator接口要求有泛型），数组是非基本类型，可以用其排序。本题排序是根据右边界排序，一个测试用例是[[1,2], [2,3, [3,4], [1, 3]]，经过排序后变为：[[1,2], [2,3, [1,3], [3, 4]]。可见对于未指定a[1] == b[1]如何排序时，顺序是保持原来顺序的。

> 这道题是区间问题的典型解法：根据区间的端值进行定制排序。
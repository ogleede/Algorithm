## 树



**[剑指Offer II 48 序列化与反序列化二叉树 - Hard](https://leetcode-cn.com/problems/h54YBf/)**

```java
//dfs
public class Codec {
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null) return "n";
        return root.val + "," + serialize(root.left) + "," + serialize(root.right);
    }
    
    private TreeNode dfs(Queue<String> queue) {
        String poll = queue.poll();
        if("n".equals(poll)) return null;
        TreeNode root = new TreeNode(Integer.parseInt(poll));
        root.left = dfs(queue);
        root.right = dfs(queue);
        return root;
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(",")));
        return dfs(queue);
    }
}
```

```java
//dfs_ StringBuilder
public class Codec {
    private void dfsEncode(TreeNode root, StringBuilder sb) {
        if(root == null) {
            sb.append("n,");
            return;
        }
        sb.append(root.val).append(",");
        dfsEncode(root.left, sb);
        dfsEncode(root.right, sb);
    }
        
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null) return "n";
        StringBuilder sb = new StringBuilder();
        dfsEncode(root, sb);
        return sb.toString();
    }
    
    private TreeNode dfsDecode(Queue<String> queue) {
        String poll = queue.poll();
        if("n".equals(poll)) return null;
        TreeNode root = new TreeNode(Integer.parseInt(poll));
        root.left = dfsDecode(queue);
        root.right = dfsDecode(queue);
        return root;
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(",")));
        return dfsDecode(queue);
    }
}
```



> 子函数在传参数的时候，要带上泛型，不然会默认为Object。
>
> 在字符串比较时，要用equals
>
> 在调用equals时，需要用已知字符串调用，避免poll为null



```java
//bfs
public class Codec {
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null) return "";
        StringBuilder sb = new StringBuilder();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if(node == null) sb.append("n,");
            else {
                sb.append(node.val).append(",");
                queue.add(node.left);
                queue.add(node.right);
            }
        }
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if("".equals(data)) return null;
        String[] str = data.split(",");
        TreeNode root = new TreeNode(Integer.parseInt(str[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        int i = 1;
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if(!"n".equals(str[i])) {
                node.left = new TreeNode(Integer.parseInt(str[i]));
                queue.add(node.left);
            }
            ++i;
            if(!"n".equals(str[i])) {
                node.right = new TreeNode(Integer.parseInt(str[i]));
                queue.add(node.right);
            }
            ++i;
        }
        return root;
    }
}
```

> 和其他遍历不同，序列化时，要把null节点也要考虑进去



**[Leetcode 428 N叉树的序列化与反序列化 - Hard](https://leetcode-cn.com/problems/serialize-and-deserialize-n-ary-tree/submissions/)**

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;
    public Node() {}
    public Node(int _val) {
        val = _val;
    }
    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/
class Codec {
    private void dfsEncode(Node root, StringBuilder sb) {
        if(root == null) {
            sb.append("n,");
            return;
        }
        sb.append(root.val).append(",").append(root.children.size()).append(",");
        for(Node child : root.children) dfsEncode(child, sb);
    }
    
    // Encodes a tree to a single string.
    public String serialize(Node root) {
        if(root == null) return "";
        StringBuilder sb = new StringBuilder();
        dfsEncode(root, sb);
        return sb.toString();
    }
	
    private Node dfsDecode(Queue<String> queue) {
        String poll = queue.poll();
        if("n".equals(poll)) return null;
        Node root = new Node(Integer.parseInt(poll), new ArrayList<Node>());
        int size = Integer.parseInt(queue.poll());
        for (int j = 0; j < size; j++) {
            Node child = dfsDecode(queue);
            root.children.add(child);
        }
        return root;
    }
    
    public Node deserialize(String data) {
        if (data == null || data.isEmpty()) return null;
        Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(",")));
        return dfsDecode(queue);
    }

}
```

> 题目要求不能用全局变量，这个好实现。主要思想是要 记录每个子节点的分叉个数。